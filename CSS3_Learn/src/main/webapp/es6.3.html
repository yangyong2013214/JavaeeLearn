<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    //这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值
    //    var [a, b, c] = [1, 2, 3];
    //    console.log(a, b, c);//1, 2, 3

    //    let [foo, [[bar], baz]] = [1, [[2], 3]];
    //    console.log(foo, bar, baz);//1, 2, 3

    //    let [ , , third] = ["foo", "bar", "baz"];
    //    console.log(third); //"baz"

    //...tail 表示数组
    //    let [head, ...tail] = [1, 2, 3, 4];
    //    console.log(head, tail); //1, [2, 3, 4]

    //    let [x, y, ...z] = ['a'];
    //    console.log(x, y, z); //a, undefined, []

    //如果解构不成功，变量的值就等于undefined。
    //    var [foo] = [];
    //    console.log(foo); //undefined

    //    var [bar, foo] = [1];
    //    console.log(bar, foo); //1, undefined

    //    另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。
    //    let [x, y] = [1, 2, 3];
    //    console.log(x, y); //1, 2
    //
    //    let [a, [b], d] = [1, [2, 3], 4];
    //    console.log(a, b, d); //1, 2, 4

    //    let [foo] = 1; //TypeError: undefined is not a function
    //    let [foo] = false;
    //    let [foo] = NaN;
    //    let [foo] = undefined;
    //    let [foo] = null;
    //    let [foo] = {};
    //    上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口

    let [x, y, z] = new Set(["a", "b", "c"]);
    console.log(x, y, z); //a, b, c


    function* fibs() {
        var a = 0;
        var b = 1;
        while (true) {
            yield a;
            [a, b] = [b, a + b];
        }
    }



</script>
</body>
</html>